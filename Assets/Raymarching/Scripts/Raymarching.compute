#pragma kernel CSMain

Texture2D<float4> Source;
RWTexture2D<float4> Destination;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

static const float maxDst = 80;
static const float epsilon = 0.001f;


struct Ray
{
    float3 origin;
    float3 direction;
};

float SphereDistance(float3 eye, float3 centre, float radius)
{
    return distance(eye, centre) - radius;
}

Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv)
{
    float3 origin = mul(_CameraToWorld, float4(0, 0, 0, 1)).xyz;
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0, 1)).xyz;
    direction = mul(_CameraToWorld, float4(direction, 0)).xyz;
    direction = normalize(direction);
    return CreateRay(origin, direction);
}


float4 SceneInfo(float3 eye)
{
    float globalDst = maxDst;
    float3 globalColour = 1;
    
    globalColour = float3(1, 1, 1);
    globalDst = SphereDistance(eye, float3(0, 0, 0), 1);

    return float4(globalColour, globalDst);
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Destination.GetDimensions(width, height);

    // Destination[id.xy] = Source[id.xy];

    float2 uv = id.xy / float2(width, height) * 2 - 1;
    float rayDst = 0;

    Ray ray = CreateCameraRay(uv);
    int marchSteps = 0;
    
    while (rayDst < maxDst)
    {
        marchSteps++;
        float4 sceneInfo = SceneInfo(ray.origin);
        float dst = sceneInfo.w;
        
        if (dst <= epsilon)
        {
            float3 pointOnSurface = ray.origin + ray.direction * dst;
            float3 col = sceneInfo.xyz;

            Destination[id.xy] = float4(col, 1);

            break;
        }
        
        Destination[id.xy] = float4(0, 0, 0, 1);

        ray.origin += ray.direction * dst;
        rayDst += dst;
    }
}